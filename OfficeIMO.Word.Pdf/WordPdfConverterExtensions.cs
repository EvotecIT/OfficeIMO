using DocumentFormat.OpenXml;
using OfficeIMO.Word;
using QuestPDF.Drawing;
using QuestPDF.Fluent;
using QuestPDF.Helpers;
using QuestPDF.Infrastructure;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using System.Reflection;
using System.Runtime.Loader;
using W = DocumentFormat.OpenXml.Wordprocessing;

namespace OfficeIMO.Word.Pdf {

    /// <summary>
    /// Provides extension methods for converting <see cref="WordDocument"/> instances to PDF files.
    /// </summary>
    public static partial class WordPdfConverterExtensions {
        /// <summary>
        /// Saves the specified <see cref="WordDocument"/> as a PDF at the given <paramref name="path"/>.
        /// </summary>
        /// <param name="document">The document to convert.</param>
        /// <param name="path">The output PDF file path.</param>
        /// <param name="options">Optional PDF configuration.</param>
        public static void SaveAsPdf(this WordDocument document, string path, PdfSaveOptions? options = null) {
            if (document == null) {
                throw new ArgumentNullException(nameof(document));
            }

            if (path == null) {
                throw new ArgumentNullException(nameof(path));
            }

            if (string.IsNullOrWhiteSpace(path)) {
                throw new ArgumentException("Path cannot be empty or whitespace.", nameof(path));
            }

            string? directory = Path.GetDirectoryName(path);
            if (!string.IsNullOrEmpty(directory)) {
                Directory.CreateDirectory(directory);
            }

            var originalLicense = QuestPdfLicenseUtil.GetEffectiveLicenseValue();
            try {
                Document pdf = CreatePdfDocument(document, options);
                pdf.GeneratePdf(path);
            } finally {
                // Restore whatever license was set before conversion across all loaded QuestPDF TFMs
                QuestPdfLicenseUtil.SetLicenseForAll(originalLicense);
            }
        }

        /// <summary>
        /// Saves the specified <see cref="WordDocument"/> as a PDF to the provided <paramref name="stream"/>.
        /// </summary>
        /// <param name="document">The document to convert.</param>
        /// <param name="stream">The output stream to receive the PDF data.</param>
        /// <param name="options">Optional PDF configuration.</param>
        public static void SaveAsPdf(this WordDocument document, Stream stream, PdfSaveOptions? options = null) {
            if (document == null) {
                throw new ArgumentNullException(nameof(document));
            }

            if (stream == null) {
                throw new ArgumentNullException(nameof(stream));
            }

            if (!stream.CanWrite) {
                throw new ArgumentException("Stream must be writable.", nameof(stream));
            }

            var originalLicense = QuestPdfLicenseUtil.GetEffectiveLicenseValue();
            try {
                Document pdf = CreatePdfDocument(document, options);
                pdf.GeneratePdf(stream);

                if (stream.CanSeek) {
                    stream.Position = 0;
                }
            } finally {
                QuestPdfLicenseUtil.SetLicenseForAll(originalLicense);
            }
        }

        /// <summary>
        /// Saves the specified <see cref="WordDocument"/> as a PDF and returns the generated bytes.
        /// </summary>
        /// <param name="document">The document to convert.</param>
        /// <param name="options">Optional PDF configuration.</param>
        /// <returns>The generated PDF as a byte array.</returns>
        public static byte[] SaveAsPdf(this WordDocument document, PdfSaveOptions? options = null) {
            if (document == null) {
                throw new ArgumentNullException(nameof(document));
            }

            var originalLicense = QuestPdfLicenseUtil.GetEffectiveLicenseValue();
            try {
                using (MemoryStream stream = new MemoryStream()) {
                    Document pdf = CreatePdfDocument(document, options);
                    pdf.GeneratePdf(stream);
                    return stream.ToArray();
                }
            } finally {
                QuestPdfLicenseUtil.SetLicenseForAll(originalLicense);
            }
        }

        /// <summary>
        /// Saves the specified <see cref="WordDocument"/> as a PDF and returns the generated bytes asynchronously.
        /// </summary>
        /// <param name="document">The document to convert.</param>
        /// <param name="options">Optional PDF configuration.</param>
        /// <param name="cancellationToken">A token to observe while waiting for the task to complete.</param>
        /// <returns>The generated PDF as a byte array.</returns>
        public static async Task<byte[]> SaveAsPdfAsync(this WordDocument document, PdfSaveOptions? options = null, CancellationToken cancellationToken = default) {
            if (document == null) {
                throw new ArgumentNullException(nameof(document));
            }

            using (MemoryStream stream = new MemoryStream()) {
                cancellationToken.ThrowIfCancellationRequested();
                Document pdf = CreatePdfDocument(document, options);
                await Task.Run(() => pdf.GeneratePdf(stream), cancellationToken).ConfigureAwait(false);
                stream.Position = 0;
                return stream.ToArray();
            }
        }

        /// <summary>
        /// Saves the specified <see cref="WordDocument"/> as a PDF at the given <paramref name="path"/> asynchronously.
        /// </summary>
        /// <param name="document">The document to convert.</param>
        /// <param name="path">The output PDF file path.</param>
        /// <param name="options">Optional PDF configuration.</param>
        /// <param name="cancellationToken">A token to observe while waiting for the task to complete.</param>
        /// <returns>A task representing the asynchronous operation.</returns>
        public static Task SaveAsPdfAsync(this WordDocument document, string path, PdfSaveOptions? options = null, CancellationToken cancellationToken = default) {
            if (document == null) {
                throw new ArgumentNullException(nameof(document));
            }

            if (path == null) {
                throw new ArgumentNullException(nameof(path));
            }

            if (string.IsNullOrWhiteSpace(path)) {
                throw new ArgumentException("Path cannot be empty or whitespace.", nameof(path));
            }

            string? directory = Path.GetDirectoryName(path);
            cancellationToken.ThrowIfCancellationRequested();
            if (!string.IsNullOrEmpty(directory)) {
                Directory.CreateDirectory(directory);
            }

            Document pdf = CreatePdfDocument(document, options);
            return Task.Run(() => pdf.GeneratePdf(path), cancellationToken);
        }

        /// <summary>
        /// Saves the specified <see cref="WordDocument"/> as a PDF to the provided <paramref name="stream"/> asynchronously.
        /// </summary>
        /// <param name="document">The document to convert.</param>
        /// <param name="stream">The output stream to receive the PDF data.</param>
        /// <param name="options">Optional PDF configuration.</param>
        /// <param name="cancellationToken">A token to observe while waiting for the task to complete.</param>
        /// <returns>A task representing the asynchronous operation.</returns>
        public static Task SaveAsPdfAsync(this WordDocument document, Stream stream, PdfSaveOptions? options = null, CancellationToken cancellationToken = default) {
            if (document == null) {
                throw new ArgumentNullException(nameof(document));
            }

            if (stream == null) {
                throw new ArgumentNullException(nameof(stream));
            }

            cancellationToken.ThrowIfCancellationRequested();

            if (!stream.CanWrite) {
                throw new ArgumentException("Stream must be writable.", nameof(stream));
            }

            var originalLicense = QuestPdfLicenseUtil.GetEffectiveLicenseValue();
            Document pdf = CreatePdfDocument(document, options);
            return Task.Run(() => {
                try {
                    pdf.GeneratePdf(stream);
                    if (stream.CanSeek) {
                        stream.Position = 0;
                    }
                } finally {
                    QuestPdfLicenseUtil.SetLicenseForAll(originalLicense);
                }
            }, cancellationToken);
        }

        private static Document CreatePdfDocument(WordDocument document, PdfSaveOptions? options) {
            // Respect an existing license from any loaded QuestPDF TFM; only set when none is present
            if (QuestPdfLicenseUtil.GetEffectiveLicenseValue() == null) {
                var desired = options?.QuestPdfLicenseType ?? LicenseType.Community;
                QuestPdfLicenseUtil.SetLicenseForAll((int)desired);
            }

            RegisterFonts(options);

            BuiltinDocumentProperties properties = document.BuiltinDocumentProperties;
            Dictionary<WordParagraph, (int Level, string Marker)> listMarkers = DocumentTraversal.BuildListMarkers(document);

            Document pdf = Document.Create(container => {
                foreach (WordSection section in document.Sections) {
                    container.Page(page => {
                        if (options?.FontFamily is { Length: > 0 } fontFamily) {
                            page.DefaultTextStyle(t => t.FontFamily(fontFamily));
                        }

                        if (options?.MarginLeft != null || options?.MarginRight != null || options?.MarginTop != null || options?.MarginBottom != null) {
                            float left = options.MarginLeft ?? options.Margin ?? (section.Margins.Left?.Value ?? 0) / 20f;
                            Unit leftUnit = options.MarginLeft != null ? options.MarginLeftUnit : options.Margin != null ? options.MarginUnit : Unit.Point;
                            float right = options.MarginRight ?? options.Margin ?? (section.Margins.Right?.Value ?? 0) / 20f;
                            Unit rightUnit = options.MarginRight != null ? options.MarginRightUnit : options.Margin != null ? options.MarginUnit : Unit.Point;
                            float top = options.MarginTop ?? options.Margin ?? (section.Margins.Top ?? 0) / 20f;
                            Unit topUnit = options.MarginTop != null ? options.MarginTopUnit : options.Margin != null ? options.MarginUnit : Unit.Point;
                            float bottom = options.MarginBottom ?? options.Margin ?? (section.Margins.Bottom ?? 0) / 20f;
                            Unit bottomUnit = options.MarginBottom != null ? options.MarginBottomUnit : options.Margin != null ? options.MarginUnit : Unit.Point;

                            page.MarginLeft(left, leftUnit);
                            page.MarginRight(right, rightUnit);
                            page.MarginTop(top, topUnit);
                            page.MarginBottom(bottom, bottomUnit);
                        } else if (options?.Margin != null) {
                            page.Margin(options.Margin.Value, options.MarginUnit);
                        } else {
                            float leftMargin = (section.Margins.Left?.Value ?? 0) / 20f;
                            float rightMargin = (section.Margins.Right?.Value ?? 0) / 20f;
                            float topMargin = (section.Margins.Top ?? 0) / 20f;
                            float bottomMargin = (section.Margins.Bottom ?? 0) / 20f;
                            page.MarginLeft(leftMargin, Unit.Point);
                            page.MarginRight(rightMargin, Unit.Point);
                            page.MarginTop(topMargin, Unit.Point);
                            page.MarginBottom(bottomMargin, Unit.Point);
                        }

                        PageSize size;
                        if (options?.PageSize != null) {
                            size = options.PageSize;
                        } else if (section.PageSettings.PageSize.HasValue) {
                            size = MapToPageSize(section.PageSettings.PageSize.Value);
                        } else if (options?.DefaultPageSize.HasValue == true) {
                            size = MapToPageSize(options.DefaultPageSize.Value);
                        } else {
                            size = PageSizes.A4;
                        }

                        PdfPageOrientation orientation;
                        if (options?.Orientation != null) {
                            orientation = options.Orientation.Value;
                        } else if (section.PageSettings.Orientation == W.PageOrientationValues.Landscape) {
                            orientation = PdfPageOrientation.Landscape;
                        } else if (options?.DefaultOrientation != null) {
                            orientation = options.DefaultOrientation == W.PageOrientationValues.Landscape ? PdfPageOrientation.Landscape : PdfPageOrientation.Portrait;
                        } else {
                            orientation = PdfPageOrientation.Portrait;
                        }

                        if (orientation == PdfPageOrientation.Landscape) {
                            size = size.Landscape();
                        } else {
                            size = size.Portrait();
                        }

                        page.Size(size);

                        List<PdfFootnote> footnotes = new();
                        Dictionary<WordParagraph, int> footnoteMap = new();
                        int footnoteCounter = 1;

                        CollectFootnotes(section.Elements, footnotes, footnoteMap, ref footnoteCounter);

                        RenderHeader(page, section, footnotes, footnoteMap);

                        page.Content().Column(column => {
                            foreach (WordElement element in section.Elements) {
                                RenderElement(column, element, GetMarker, options, footnoteMap);
                            }
                        });

                        RenderFooter(page, section, footnotes, footnoteMap);
                    });
                }
            })
            .WithMetadata(new DocumentMetadata {
                Title = options?.Title ?? properties.Title,
                Author = options?.Author ?? properties.Creator,
                Subject = options?.Subject ?? properties.Subject,
                Keywords = options?.Keywords ?? properties.Keywords
            });

            return pdf;

            (int Level, string Marker)? GetMarker(WordParagraph paragraph) {
                if (listMarkers.TryGetValue(paragraph, out var value)) {
                    return value;
                }

                return null;
            }

            void RenderElements(ColumnDescriptor column, IEnumerable<WordParagraph> paragraphs, IEnumerable<WordTable> tables, IEnumerable<WordImage> images, IEnumerable<WordHyperLink> links, Dictionary<WordParagraph, int> footnoteMap) {
                foreach (WordParagraph paragraph in paragraphs) {
                    RenderElement(column, paragraph, GetMarker, options, footnoteMap);
                }

                foreach (WordTable table in tables) {
                    RenderElement(column, table, GetMarker, options, footnoteMap);
                }

                foreach (WordImage image in images) {
                    RenderElement(column, image, GetMarker, options, footnoteMap);
                }

                foreach (WordHyperLink link in links) {
                    RenderElement(column, link, GetMarker, options, footnoteMap);
                }
            }

            void RenderHeader(PageDescriptor page, WordSection section, List<PdfFootnote> footnotes, Dictionary<WordParagraph, int> footnoteMap) {
                if (section.Header == null) return;
                bool hasContent =
                    (section.Header.Default != null && (section.Header.Default.Paragraphs.Count > 0 || section.Header.Default.Tables.Count > 0 || section.Header.Default.Images.Count > 0 || section.Header.Default.HyperLinks.Count > 0)) ||
                    (section.Header.First != null && (section.Header.First.Paragraphs.Count > 0 || section.Header.First.Tables.Count > 0 || section.Header.First.Images.Count > 0 || section.Header.First.HyperLinks.Count > 0)) ||
                    (section.Header.Even != null && (section.Header.Even.Paragraphs.Count > 0 || section.Header.Even.Tables.Count > 0 || section.Header.Even.Images.Count > 0 || section.Header.Even.HyperLinks.Count > 0));
                if (!hasContent) return;

                page.Header().Layers(layers => {
                    if (section.Header.Default != null && (section.Header.Default.Paragraphs.Count > 0 || section.Header.Default.Tables.Count > 0 || section.Header.Default.Images.Count > 0 || section.Header.Default.HyperLinks.Count > 0)) {
                        layers.PrimaryLayer().ShowIf(x => (section.Header.First == null || x.PageNumber > 1) && (section.Header.Even == null || x.PageNumber % 2 == 1)).Column(col => {
                            RenderElements(col, section.Header.Default.Paragraphs, section.Header.Default.Tables, section.Header.Default.Images, section.Header.Default.HyperLinks, footnoteMap);
                        });
                    }

                    if (section.Header.First != null && (section.Header.First.Paragraphs.Count > 0 || section.Header.First.Tables.Count > 0 || section.Header.First.Images.Count > 0 || section.Header.First.HyperLinks.Count > 0)) {
                        layers.Layer().ShowIf(x => x.PageNumber == 1).Column(col => {
                            RenderElements(col, section.Header.First.Paragraphs, section.Header.First.Tables, section.Header.First.Images, section.Header.First.HyperLinks, footnoteMap);
                        });
                    }

                    if (section.Header.Even != null && (section.Header.Even.Paragraphs.Count > 0 || section.Header.Even.Tables.Count > 0 || section.Header.Even.Images.Count > 0 || section.Header.Even.HyperLinks.Count > 0)) {
                        layers.Layer().ShowIf(x => x.PageNumber % 2 == 0 && x.PageNumber > 1).Column(col => {
                            RenderElements(col, section.Header.Even.Paragraphs, section.Header.Even.Tables, section.Header.Even.Images, section.Header.Even.HyperLinks, footnoteMap);
                        });
                    }
                });
            }

            void RenderFooter(PageDescriptor page, WordSection section, List<PdfFootnote> footnotes, Dictionary<WordParagraph, int> footnoteMap) {
                bool includePageNumbers = options?.IncludePageNumbers ?? true;
                if (section.Footer == null && footnotes.Count == 0 && !includePageNumbers) {
                    return;
                }

                bool hasContent =
                    (section.Footer?.Default != null && (section.Footer.Default.Paragraphs.Count > 0 || section.Footer.Default.Tables.Count > 0 || section.Footer.Default.Images.Count > 0 || section.Footer.Default.HyperLinks.Count > 0)) ||
                    (section.Footer?.First != null && (section.Footer.First.Paragraphs.Count > 0 || section.Footer.First.Tables.Count > 0 || section.Footer.First.Images.Count > 0 || section.Footer.First.HyperLinks.Count > 0)) ||
                    (section.Footer?.Even != null && (section.Footer.Even.Paragraphs.Count > 0 || section.Footer.Even.Tables.Count > 0 || section.Footer.Even.Images.Count > 0 || section.Footer.Even.HyperLinks.Count > 0));

                page.Footer().Layers(layers => {
                    bool primaryDefined = false;
                    if (section.Footer != null && hasContent) {
                        if (section.Footer.Default != null && (section.Footer.Default.Paragraphs.Count > 0 || section.Footer.Default.Tables.Count > 0 || section.Footer.Default.Images.Count > 0 || section.Footer.Default.HyperLinks.Count > 0)) {
                            layers.PrimaryLayer().ShowIf(x => (section.Footer.First == null || x.PageNumber > 1) && (section.Footer.Even == null || x.PageNumber % 2 == 1)).Column(col => {
                                RenderElements(col, section.Footer.Default.Paragraphs, section.Footer.Default.Tables, section.Footer.Default.Images, section.Footer.Default.HyperLinks, footnoteMap);
                            });
                            primaryDefined = true;
                        }

                        if (section.Footer.First != null && (section.Footer.First.Paragraphs.Count > 0 || section.Footer.First.Tables.Count > 0 || section.Footer.First.Images.Count > 0 || section.Footer.First.HyperLinks.Count > 0)) {
                            layers.Layer().ShowIf(x => x.PageNumber == 1).Column(col => {
                                RenderElements(col, section.Footer.First.Paragraphs, section.Footer.First.Tables, section.Footer.First.Images, section.Footer.First.HyperLinks, footnoteMap);
                            });
                        }

                        if (section.Footer.Even != null && (section.Footer.Even.Paragraphs.Count > 0 || section.Footer.Even.Tables.Count > 0 || section.Footer.Even.Images.Count > 0 || section.Footer.Even.HyperLinks.Count > 0)) {
                            layers.Layer().ShowIf(x => x.PageNumber % 2 == 0 && x.PageNumber > 1).Column(col => {
                                RenderElements(col, section.Footer.Even.Paragraphs, section.Footer.Even.Tables, section.Footer.Even.Images, section.Footer.Even.HyperLinks, footnoteMap);
                            });
                        }
                    }

                    if (!primaryDefined) {
                        layers.PrimaryLayer();
                    }

                    if (footnotes.Count > 0) {
                        layers.Layer().Column(col => {
                            foreach (var fn in footnotes) {
                                col.Item().Text($"{fn.Number}. {fn.Text}");
                            }
                        });
                    }

                    if (includePageNumbers) {
                        layers.Layer().AlignRight().Text(text => {
                            string? format = options?.PageNumberFormat;
                            if (!string.IsNullOrWhiteSpace(format)) {
                                var tokens = Regex.Split(format, "(\\{current\\}|\\{total\\})");
                                foreach (string token in tokens) {
                                    if (token == "{current}") {
                                        text.CurrentPageNumber();
                                    } else if (token == "{total}") {
                                        text.TotalPages();
                                    } else if (token.Length > 0) {
                                        text.Span(token);
                                    }
                                }
                            } else {
                                text.CurrentPageNumber();
                                text.Span("/");
                                text.TotalPages();
                            }
                        });
                    }
                });
            }

            void CollectFootnotes(IEnumerable<WordElement> elements, List<PdfFootnote> footnotes, Dictionary<WordParagraph, int> footnoteMap, ref int footnoteCounter) {
                foreach (var element in elements) {
                    if (element is WordParagraph para) {
                        var fn = para.FootNote;
                        if (fn != null) {
                            footnoteMap[para] = footnoteCounter;
                            string text = string.Join(" ", fn.Paragraphs?.Select(p => p.Text) ?? Enumerable.Empty<string>());
                            footnotes.Add(new PdfFootnote { Number = footnoteCounter, Text = text });
                            footnoteCounter++;
                        }
                    } else if (element is WordTable t) {
                        foreach (var row in t.Rows) {
                            foreach (var cell in row.Cells) {
                                CollectFootnotes(cell.Paragraphs.Cast<WordElement>(), footnotes, footnoteMap, ref footnoteCounter);
                                CollectFootnotes(cell.NestedTables.Cast<WordElement>(), footnotes, footnoteMap, ref footnoteCounter);
                            }
                        }
                    }
                }
            }
        }

        // Helpers to read/set QuestPDF license across all loaded TFMs (net8, net9) within the process.
        private static class QuestPdfLicenseUtil {
            private const string QuestPdfAssemblyName = "QuestPDF";
            private const string SettingsTypeName = "QuestPDF.Infrastructure.Settings";
            private const string LicensePropertyName = "License";

            public static int? GetEffectiveLicenseValue() {
                foreach (var asm in EnumerateQuestPdfAssemblies()) {
                    var val = ReadLicenseFromAssembly(asm);
                    if (val != null) return val;
                }
                return null;
            }

            public static void SetLicenseForAll(int? licenseValue) {
                foreach (var asm in EnumerateQuestPdfAssemblies()) {
                    WriteLicenseToAssembly(asm, licenseValue);
                }
            }

            private static IEnumerable<Assembly> EnumerateQuestPdfAssemblies() {
                // Include all ALCs to catch mixed-TFM loads
                foreach (var alc in AssemblyLoadContext.All) {
                    foreach (var asm in alc.Assemblies) {
                        var name = asm.GetName().Name;
                        if (string.Equals(name, QuestPdfAssemblyName, StringComparison.Ordinal)) {
                            yield return asm;
                        }
                    }
                }
            }

            private static int? ReadLicenseFromAssembly(Assembly asm) {
                var settingsType = asm.GetType(SettingsTypeName);
                if (settingsType == null) return null;
                var prop = settingsType.GetProperty(LicensePropertyName, BindingFlags.Public | BindingFlags.Static);
                if (prop == null) return null;
                var val = prop.GetValue(null);
                if (val == null) return null;
                // val is an enum boxed from that asm; convert to int
                try { return Convert.ToInt32(val); } catch { return null; }
            }

            private static void WriteLicenseToAssembly(Assembly asm, int? licenseValue) {
                var settingsType = asm.GetType(SettingsTypeName);
                if (settingsType == null) return;
                var prop = settingsType.GetProperty(LicensePropertyName, BindingFlags.Public | BindingFlags.Static);
                if (prop == null) return;
                if (licenseValue == null) {
                    prop.SetValue(null, null);
                    return;
                }
                var enumType = settingsType.Assembly.GetType("QuestPDF.Infrastructure.LicenseType");
                if (enumType == null) return;
                var boxed = Enum.ToObject(enumType, licenseValue.Value);
                prop.SetValue(null, boxed);
            }
        }

        private static void RegisterFonts(PdfSaveOptions? options) {
            if (options?.FontFilePaths != null) {
                foreach (var kvp in options.FontFilePaths) {
                    if (string.IsNullOrWhiteSpace(kvp.Key) || string.IsNullOrWhiteSpace(kvp.Value)) {
                        continue;
                    }
                    if (!_embeddedFonts.Add(kvp.Key)) {
                        continue;
                    }
                    if (!File.Exists(kvp.Value)) {
                        continue;
                    }
                    using var stream = File.OpenRead(kvp.Value);
                    FontManager.RegisterFontWithCustomName(kvp.Key, stream);
                }
            }

            if (options?.FontStreams != null) {
                foreach (var kvp in options.FontStreams) {
                    if (string.IsNullOrWhiteSpace(kvp.Key) || kvp.Value == null) {
                        continue;
                    }
                    if (!_embeddedFonts.Add(kvp.Key)) {
                        continue;
                    }
                    Stream stream = kvp.Value;
                    if (stream.CanSeek) {
                        stream.Position = 0;
                    }
                    using MemoryStream ms = new();
                    stream.CopyTo(ms);
                    ms.Position = 0;
                    FontManager.RegisterFontWithCustomName(kvp.Key, ms);
                    if (stream.CanSeek) {
                        stream.Position = 0;
                    }
                }
            }
        }

    }
}
